//kruskal's

#include <iostream>
#include <vector>
#include <algorithm>
#include <chrono>
using namespace std;
using namespace std::chrono;
// Structure to represent an edge in the graph
struct Edge {
int src, dest, weight;
};
// Structure to represent a subset for union-find
struct Subset {
int parent, rank;
};
// Comparator function for sorting edges by weight
bool compareEdges(const Edge& e1, const Edge& e2) {
return e1.weight < e2.weight;
}
// Find operation for disjoint set (with path compression)
int find(vector<Subset>& subsets, int i) {
if (subsets[i].parent != i) {
subsets[i].parent = find(subsets, subsets[i].parent);
}
return subsets[i].parent;
}
// Union operation for disjoint set (with union by rank)
void Union(vector<Subset>& subsets, int x, int y) {
int rootX = find(subsets, x);
int rootY = find(subsets, y);
if (subsets[rootX].rank < subsets[rootY].rank) {
subsets[rootX].parent = rootY;
} else if (subsets[rootX].rank > subsets[rootY].rank) {
subsets[rootY].parent = rootX;
} else {
subsets[rootY].parent = rootX;
subsets[rootX].rank++;
}
}
// Kruskal's algorithm for finding MST
void KruskalMST(vector<Edge>& edges, int V) {
auto start = high_resolution_clock::now();
vector<Edge> MST; // Stores the edges of MST
vector<Subset> subsets(V); // Stores the subsets for union-find
// Initialize subsets
for (int i = 0; i < V; ++i) {
subsets[i].parent = i;
subsets[i].rank = 0;
}
// Sort edges by weight
sort(edges.begin(), edges.end(), compareEdges);
// Process each edge in sorted order
for (const Edge& edge : edges) {
int srcRoot = find(subsets, edge.src);
int destRoot = find(subsets, edge.dest);
// If including this edge does not create a cycle, add it to MST
if (srcRoot != destRoot) {
MST.push_back(edge);
Union(subsets, srcRoot, destRoot);
}
}
auto stop = high_resolution_clock::now();
auto duration = duration_cast<microseconds>(stop - start);
// Display MST and time complexity
cout << "Minimum Spanning Tree (MST):" << endl;
for (const Edge& edge : MST) {
cout << edge.src << " - " << edge.dest << " : " << edge.weight << endl;
}
cout << "Time Complexity: " << duration.count() << " microseconds" << endl;
}
int main() {
int V, E;
cout << "Enter the number of vertices and edges: ";
cin >> V >> E;
vector<Edge> edges(E);
cout << "Enter the edges (source destination weight):" << endl;
for (int i = 0; i < E; ++i) {
cin >> edges[i].src >> edges[i].dest >> edges[i].weight;
}
KruskalMST(edges, V);
return 0;
}

